# 内存管理

## 内存分布（物理地址）

```sh
MAX_MEM     --------------------------------------
                    k_mm_alloc_page/ k_mm_alloc_mem
0x83000000  -------------------------------------- (FREEMEM)
                    k_mm_malloc
0x81110000  -------------------------------------- (FREEMEMK)
                    pid0_pcb stack
0x81100000  -------------------------------------- 
                    init_pgdir
0x81010000  -------------------------------------- (PGDIR_PA)
                    kernel stack
0x80903000  --------------------------------------
                    init kernel stack
0x80900000  --------------------------------------
                    Kernel
0x80200000  --------------------------------------
                    OpenSBI
0x80000000  --------------------------------------
```

## Cgroup
每个pid都有MAXPAGES的页数限制，起到Cgroup的作用，超过了Cgroup限制会触发swap out。由于对于磁盘的读写会造成大量不必要的io，因此我们这里提高了cgroup的阈值，并暂时暂停了swap操作。

## 内存回收
内存管理系统维护有数组all_mem，用来统计每个pid申请的内存页的虚拟地址和物理地址。

内存回收函数 getback_page 在 kill 调用，kill 被 sys_exit 调用。把前面记录的分配的all_mem与all_page都回收到freepg数组。共享内存页不会释放，交给用户自己释放。

在全国赛中，由于测试程序内存使用量激增，该数组的地址记录本身也占用了大量的内核内存。因此在全国赛中，我们放弃了这种简单的内存回收机制，并期望实现更高效的内存回收和记录机制，比如伙伴系统等。

## 内存分配

+ k_mm_alloc_mem 内存分配函数从FREEMEM开始分配内存。
如果有刚回收的空闲内存页，优先分配这些刚回收的内存页

+ k_mm_alloc_page 专门分配页表的空间，不会进行Cgroup限制，也不会swap out，但是有回收机制

+ k_mm_malloc 主要为内核分配内存空间，不会进行内存回收，和前面两个用户内存函数彼此数据隔离

## 虚存

虚存主要在prepare_vm进行映射的建立和虚存的开启。

我们支持按需分配物理内存，当触发load或store的page fault时，进行页表项检查，如果没有虚实地址映射，则分配物理地址并建立映射。

同时通过虚存机制，我们支持fork的copy-on-write，即在触发store page fault时检查父子进程关系，为父子进程分配不同的物理地址。