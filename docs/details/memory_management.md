# 内存管理

## 内存分布（物理地址）

```sh
0x88000000  -------------------------------------- (128M)
                    k_malloc
0x83000000  -------------------------------------- (FREEMEMK)
                    free space (*)
0x82000000  -------------------------------------- (PGDIR_PA)
                    k_alloc_page / k_alloc_mem
0x81010000  -------------------------------------- (FREEMEM)
                    free space (*)
0x81005000  --------------------------------------
                    pid0_pcb kernel stack
0x81003000  --------------------------------------
                    pid0_pcb kernel stack
0x80502000  --------------------------------------
                    Core1 stack
0x80501000  --------------------------------------
                    Core0 stack
0x80500000  --------------------------------------
                    Kernel
0x80200000  --------------------------------------
                    OpenSBI
0x80000000  --------------------------------------
```
( * ) 未来工作是改进当前内存管理中过多的内存碎片，以及约定式的内存分配。

## Cgroup
每个pid都有MAXPAGES的页数限制，起到Cgroup的作用，超过了Cgroup限制会触发swap out（待维护）。

## 内存回收
内存管理系统维护有数组all_mem，用来统计每个pid申请的内存页的虚拟地址和物理地址。

内存回收函数 getback_page 在 kill 调用，kill 被 sys_exit 调用。把前面记录的分配的all_mem与all_page都回收到freepg数组。共享内存页不会释放，交给用户自己释放

## 内存分配

+ k_alloc_mem 内存分配函数从FREEMEM开始分配内存。
如果有刚回收的空闲内存页，优先分配这些刚回收的内存页

+ k_alloc_page 专门分配页表的空间，不会进行Cgroup限制，也不会swap out，但是有回收机制

+ k_malloc 主要为内核分配内存空间，不会进行内存回收，和前面两个用户内存函数彼此数据隔离

## 虚存

虚存主要在prepare_vm进行映射的建立和虚存的开启。

我们支持按需分配物理内存，当触发load或store的page fault时，进行页表项检查，如果没有虚实地址映射，则分配物理地址并建立映射。

同时通过虚存机制，我们支持fork的copy-on-write，即在触发store page fault时检查父子进程关系，为父子进程分配不同的物理地址。