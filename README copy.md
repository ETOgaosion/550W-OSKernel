#### 功能实现（C-core）

+ 所有S-core的基本功能
+ 实现文件系统、大文件支持、硬链接操作、文件详细信息命令、多级目录等
+ 实现全功能测试

#### 使用说明

1. 使用make all命令编译生成所有文件
2. 在当前目录下使用run_qemu.sh运行，或使用make floppy命令拷贝到SD卡，上板运行。（由于qemu对磁盘操作的支持不稳定，建议拷贝到板子上运行）
2. 在loadbootm后，输入0或1选择操作系统0或1，两个操作系统本身功能没有区别，主要用来测试双系统支持。
3. 可以自由使用文件系统的命令进行文件系统测试，如`cd, mkdir, rmdir, touch, rm, ls, statfs, mkfs, cat`等。也可以运行测试文件，如`exec fs, exec bigfile, exec all, exec emo`进行测试。

#### 特别说明

+ `fs`进程会打开（如果不存在会创建）`1.txt`文件，并写入10句`hello world`，然后读出写入的内容并打印。可以使用cat命令查看文件内容。
+ `bigfile`进程和`fs`类似，但是会使用`lseek`系统调用在16MB大小的位置写入`goodbye world`，然后读出写入内容并打印。使用`cat`命令会看到文件第一个扇区写入的`hello world`字符串。关于大文件支持的正确性，参考`statfs`中扇区的占用情况变化：空间按照4KB为一个数据块分配，如果文件没有写入内容，则不分配空间。对于大文件，还需要考虑间址块占用的空间，敬请特别注意，bigfile进程理论上需要新的块4个（第一个扇区写入需要一个，二级间址需要两个，16MB位置写入需要一个）
+ `emo`进程会通过轮询的方式等待接收测试文件`test_all`，然后将该文件写入文件系统，命名`all2`，用户可以通过`exec all2`将该测试文件从文件系统中启动，启动后的`all2`进程和下文的`all`进程具有同样的功能。
+ `all`进程会测试操作系统的众多功能。首先该进程会fork一个子进程（测试fork以及copy-on-write），然后父子进程分别启动三个线程（测试线程支持），父进程三个线程中，一个收包（测试网卡驱动），一个监听50001端口，并通过共享内存将包传递给子进程的一个线程（测试双端口监听以及共享内存），一个监听58688端口，通过mailbox将包传递给子进程的一个线程（测试双端口监听以及mailbox同步）；子进程三个线程中，一个将从共享内存接收包，一个从mailbox接收包，另一个线程将收到的包写入文件all.txt（测试文件系统）。之后可以通过`exec check [packet_num]`来打印文件内packet_num编号的包的内容，与wireshark的结果比较可以验证测试正确与否。（由于cat仅支持字符打印，因此使用额外的进程帮助打印包的内容，check进程通过系统调用做文件seek和读）
+ 启动`all`进程后，可以同步启动`fly`进程，屏幕上会打印小飞机。这时可以测试taskset以及双核功能。如果使用taskset将所有线程（包括fly）掩码设置为0x1（或0x2），则所有线程运行在单核上，此时如果外界发包，可以观察`all`进程最后完成文件写入时的耗费ticks，一般是5开头的一个数字。如果将fly的掩码设置为另一个数字，则该进程和all进程的线程运行在不同的核上，一般而言，飞机会比之前流畅一点点，你也可以观察到`all`进程最后的耗费ticks在6或7开头的数字。为什么时间反而变长了？首先说明，时间不同意味着这确实是双核系统，具体原因在于本操作系统是大内核锁，因此尽管双核，但是内核无法并行，而fly进程全都是需要内核配合的printf系统调用，因此fly进程的多次调度会阻碍all进程的运行，因此all进程的运行时间会变长，这也侧面反映出taskset功能的正确性。
+ 为了避免丢包，`emo`进程采用轮询式收包，同时固定收包数量较大，需要收满才可以继续运行。
+ 为了能在虚拟机里发包，需要设计虚拟机的网卡为桥接模式，这时可能有杂音包的干扰（原因未知），建议`emo`进程启动后立刻发送测试文件，避免杂音包的干扰。`all/all2`进程具有一定抗干扰能力，可以通过多次发包多次触发网卡中断的形式将杂音包除去。
+ 此项目在本地编译运行及上板效果正常，如果在您的机器上出现任何问题，请及时联系作者。

#### 项目作者

+ 姓名：张玉龙
+ 学号：2019K8009929036
+ 班级：1906
+ 邮箱：zhangyulong191@mails.ucas.ac.cn

